# Room Database

It is an abstract of mysql database. It makes things simple from mySql database.

It contains 3 components:

1. Database (abstract class extending **RoomDatabase**)
2. Entity (Represents table or a Row in Database)
3. DAO (Every Entity needs a DAO (Data Access Object) Interface, It contains functions to access or manupolate our database)

**add these dependencies in project**

```groovy
// Room Database
def room_version = "2.4.3"

implementation "androidx.room:room-runtime:$room_version"
annotationProcessor "androidx.room:room-compiler:$room_version"


// Lifecycle
def lifecycle_version = "2.6.0-alpha01"
// ViewModel
implementation "androidx.lifecycle:lifecycle-viewmodel:$lifecycle_version"
// LiveData
implementation "androidx.lifecycle:lifecycle-livedata:$lifecycle_version"
// Annotation processor
annotationProcessor "androidx.lifecycle:lifecycle-compiler:$lifecycle_version"
```



**Room Database Transactions**

1. Create Database
2. Create Table
3. Add new Data (Insert)
4. Show data in app (Query)
5. Data Update (Update)
6. Data Delete (Delete)

## Architectural Room DataBase

1. UI Controller :- Display Data and forward on UI events (**View**)
2. LiveData(**ViewModel**) :- Holds all the data needed for UI. (UI is notified for changes in LiveData)
3. Repository :-  clean API for UI to communicate with.
4. Database (Room Database) :- Contains Entity and DAOs.





## Create an Entity Class

Create a class and just annotate it with `@Entity`. One can also define a name for the table by appending `@Entity` with `(tableName = "note_table")`. 

A particular value/column can be set as **primary key** with annotation `@PrimaryKey`. This will make sure that every value under this column is unique. This value can be autogenerated by using `@PrimaryKey(autoGenerate = true)`.  Even if a primary key is set to autogenerate we still needs an setter method.

```java
@Entity(tableName = "note_table")
public class Note {

    @PrimaryKey(autoGenerate = true)
    private int id;
    private String title;
    private String description;

    public Note(String title, String description) {
        this.title = title;
        this.description = description;
    }

    public int getId() {
        return id;
    }

    public String getTitle() {
        return title;
    }

    public String getDescription() {
        return description;
    }

    public void setId(int id) {
        this.id = id;
    }
}
```

 

## Create an DAO Interface (Data Access Object)

DAO is an interface annotated with `@Dao`. Here we will declare Database operations like `update, insert, query, delete`. There is no need to implement these methods in DAO interface. We don't need any implementation of these methods as DAO will automatically handle their implementation but we need to annotate these methods with `Insert, Update, Delete, Query` as below.

```java
@Dao
public interface NotesDAO {

    @Insert
    void insert(Note note);

    @Update
    void update(Note note);

    @Delete
    void delete(Note note);

    // below query will list all the notes from note_table
    // sorted in ascending order of id. DESC is for descending
    @Query("SELECT * FROM note_table ORDER BY id ASC")
    LiveData<List<Note>> getAllNotes();
}
```

For Query we need to write sql query to be called. It is good to use LiveData as these DataStructures will be observed by the application and any changes in their values will notify the adapter or activity using these.



## Create Database

We will create a Database class which will connect `Entity` with `Dao`. This class will be an abstract class extending `RoomDatabase` and will follow singleton class structure. 

1. Create Database class with annotation `@Database(entities = {Record.class}, version = 1)`
2. This class will also cotains a static instance of itself (this database class itself).
3. An abstract method returning `Dao` object.
4. A `static synchronized` method returning instance of itself created in 2nd step.
5. will create instance in constructor class with using `Room.databaseBuilder`



**Database class itself**

```java
@Database(entities = {Note.class}, version = 1)
public abstract class NoteDatabase extends RoomDatabase {
    // Instance of NoteDatabase class
    private static NoteDatabase instance;
	// notesD
    public abstract NotesDAO notesDAO();

    public static synchronized NoteDatabase getInstance(Context context) {
        if (instance == null) {
            instance = Room.databaseBuilder(context.getApplicationContext(),
                            NoteDatabase.class, "note_database")
                // will allow main thread queries which are restricted by default and a bad practise also
	               .allowMainThreadQueries() 
                // will distroy the database on upgrading version number
                    .fallbackToDestructiveMigration()
                    .addCallback(roomCallBack)  // will execute tasks from onCreate method of roomCallback
                    .build();
        }
        return instance;
    }
    
    // Callback variable 
    private static RoomDatabase.Callback roomCallBack = new RoomDatabase.Callback()  {

        @Override
        public void onCreate(@NonNull SupportSQLiteDatabase db) {
            super.onCreate(db);
            NotesDAO notesDAO = instance.notesDAO();
            ExecutorService executorService = Executors.newSingleThreadExecutor();
            executorService.execute( () -> {
                notesDAO.insert(new Note("Title 1", "Description1"));
                notesDAO.insert(new Note("Title 2", "Description2"));
                notesDAO.insert(new Note("Title 3", "Description3"));
                notesDAO.insert(new Note("Title 4", "Description4"));
            });
        }
    };
}
```



## Repository

Repository class is the one fetching data from a Database or a server. This is the bridge between Application ViewModel and Data. Application UI doesn't care where the data come from it only cares about getting it from somewhere.

In Repository we get the instance of database and implements all the methods for inserting, adding deletion etc. defined in `Dao`

Repository class has nothing special to offer and isn't very complicated to design.

Remember while creating database if `allowMainThreadQueries` isn't passed than Running a query on MainThread will result into an error. So we need to run queries on another thread by using ExecutorService or another appropriate method.

1. It needs an instance of `Dao` class to run queries as `database, entity and Dao` are acting like a single object now which is the actual database.

```java
public class NotesRepository {

    private NotesDAO notesDAO;
    private LiveData<List<Note>> noteList;

    ExecutorService executorService = Executors.newSingleThreadExecutor();

    public NotesRepository(Application application) {
        NoteDatabase database = NoteDatabase.getInstance(application);
        notesDAO = database.notesDAO();
        noteList = notesDAO.getAllNotes();
    }

    public void insert (Note note) {
        executorService.execute(new Runnable() {
            @Override
            public void run() {
                notesDAO.insert(note);
            }
        });
    }

    public void update (Note note) {
        executorService.execute(() -> notesDAO.update(note));
    }

    public void delete (Note note) {
        executorService.execute(() -> notesDAO.delete(note));
    }

    public LiveData<List<Note>> getAllNotes() {
        return noteList;
    }
}
```

 

## ViewModel

Android ViewModel is the main connection between data and views. If we need a context or application in view model to create database or sometimes for other things we should extend it with `AndroidViewModel` and if there is no need for any argument in constructor, simply extend `ViewModel`. extending with `AndroidViewModel` will create a constructor with `Application` as argument. Besides constuctor, we need to create all the necessary methods from `repository` to get access to data.



**ViewModel Class**

```java
public class NotesViewModel extends AndroidViewModel {

    private NotesRepository repository;
    private LiveData<List<Note>> notes;

    public NotesViewModel(@NonNull Application application) {
        super(application);
        repository = new NotesRepository(application);
        notes = repository.getAllNotes();
    }

    public void insert(Note note) {
        repository.insert(note);
    }

    public void update(Note note) {
        repository.update(note);
    }

    public void delete(Note note) {
        repository.delete(note);
    }

    public LiveData<List<Note>> getAllNotes() {
        return notes;
    }
}
```



## View or Activities/Fragments

In our view we need to create an instance of viewmodel class which can be done in 2 ways below

` NotesViewModel notesViewModel = new ViewModelProvider.AndroidViewModelFactory( getApplication()).create(NotesViewModel.class);`. By using this method we will create a new instance of ViewModel by running it anytime. If we run it 2nd time it will create another instance of viewmodel, which is required in very rare cases. So we should use 2nd method to create viewmodel

`booksViewModel = new ViewModelProvider(this).get(BooksViewModel.class);`. If we have created a factory for our viewmodel it can be passed after context in `ViewModelProvider` constuctor.

To have access to live data and to observe changes to it we can use below snippet.

```java
// Create ViewModel instance
NotesViewModel notesViewModel = new ViewModelProvider.AndroidViewModelFactory( getApplication()).create(NotesViewModel.class);

notesViewModel.getAllNotes().observe(this, new Observer<List<Note>>() {
    @Override
    public void onChanged(List<Note> notes) {
        // Data to be processed.
        adapter.setNoteList(notes);
    }
});
```

